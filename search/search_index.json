{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Algoritmus \u00e9s adatszerkezetek a gyakorlatban","text":""},{"location":"#bevezetes","title":"Bevezet\u00e9s","text":"<p>Ez az oldal az algoritmusok \u00e9s adatszerkezetek a gyakorlatban c\u00edm\u0171 t\u00e1rgyhoz tartoz\u00f3 statikus dokument\u00e1ci\u00f3. Itt ker\u00fclnek list\u00e1z\u00e1sra az \u00e9vk\u00f6rben elv\u00e9gzett feladatok. </p> <p>A navig\u00e1ci\u00f3 egyes elemei megfelelteth\u0151ek egy elv\u00e9gzett feladatnak.</p>"},{"location":"grading_students/","title":"Shortest Path","text":""},{"location":"grading_students/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":""},{"location":"grading_students/#implementacio","title":"Implement\u00e1ci\u00f3","text":"<pre><code>import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'gradingStudents' function below.\n     *\n     * The function is expected to return an INTEGER_ARRAY.\n     * The function accepts INTEGER_ARRAY grades as parameter.\n     */\n\n    public static List&lt;Integer&gt; gradingStudents(List&lt;Integer&gt; grades) {\n    // Write your code here\n        List&lt;Integer&gt; output = new ArrayList&lt;&gt;();\n        for (int grade : grades) {\n            if (grade &lt; 38) {\n                output.add(grade);\n                continue;\n            }\n\n            int remainer = grade % 5;\n            if (remainer &gt;= 3) {\n                output.add(grade + 5 - remainer);\n                continue;\n            }\n            output.add(grade);\n        }\n        return output;\n    }\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv(\"OUTPUT_PATH\")));\n\n        int gradesCount = Integer.parseInt(bufferedReader.readLine().trim());\n\n        List&lt;Integer&gt; grades = IntStream.range(0, gradesCount).mapToObj(i -&gt; {\n            try {\n                return bufferedReader.readLine().replaceAll(\"\\\\s+$\", \"\");\n            } catch (IOException ex) {\n                throw new RuntimeException(ex);\n            }\n        })\n            .map(String::trim)\n            .map(Integer::parseInt)\n            .collect(toList());\n\n        List&lt;Integer&gt; result = Result.gradingStudents(grades);\n\n        bufferedWriter.write(\n            result.stream()\n                .map(Object::toString)\n                .collect(joining(\"\\n\"))\n            + \"\\n\"\n        );\n\n        bufferedReader.close();\n        bufferedWriter.close();\n    }\n}\n</code></pre>"},{"location":"grading_students/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""},{"location":"grid_paths/","title":"Grid Paths I.","text":""},{"location":"grid_paths/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":"<p>Time limit: 1.00 s \u00a0|\u00a0 Memory limit: 512 MB</p> <p>Consider an n x n grid whose squares may have traps. It is not allowed to move to a square with a trap.</p> <p>Your task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.</p>"},{"location":"grid_paths/#input","title":"Input","text":"<p>The first input line has an integer n: the size of the grid.</p> <p>After this, there are n lines that describe the grid. Each line has n characters: <code>.</code> denotes an empty cell, and <code>*</code> denotes a trap.</p>"},{"location":"grid_paths/#output","title":"Output","text":"<p>Print the number of paths modulo 10^9 + 7.</p>"},{"location":"grid_paths/#constraints","title":"Constraints","text":"<ul> <li>1 &lt;= n &lt;= 1000</li> </ul>"},{"location":"grid_paths/#example","title":"Example","text":"<p>Input: 4  ....  ...  ...  *... </p>"},{"location":"grid_paths/#implementacio","title":"Implement\u00e1ci\u00f3","text":"<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    private static final int MOD = 1_000_000_000 + 7;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String firstLine = reader.readLine();\n        int size = Integer.parseInt(firstLine);\n\n        String[][] grid = new String[size][size];\n        int[][] dp = new int[size][size];\n\n        for (int i = 0; i &lt; size; i++) {\n            grid[i] = reader.readLine().split(\"\");\n        }\n\n        if (\"*\".equals(grid[0][0])) {\n            System.out.println(0);\n            return;\n        }\n        dp[0][0] = 1;\n\n        for (int i = 0; i &lt; size; i++) {\n            for (int j = 0; j &lt; size; j++) {\n                if (i == 0 &amp;&amp; j == 0) {\n                    continue;\n                }\n\n                if (\"*\".equals(grid[i][j])) {\n                    dp[i][j] = 0;\n                    continue;\n                }\n\n                if (i &gt; 0) {\n                    dp[i][j] += dp[i-1][j];\n                }\n\n                if (j &gt; 0) {\n                    dp[i][j] += dp[i][j-1];\n                }\n                dp[i][j] = dp[i][j] % MOD;\n            }\n        }\n\n        System.out.println(dp[size-1][size-1]);\n    }\n}\n</code></pre>"},{"location":"grid_paths/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""},{"location":"planets_cycles/","title":"Planets Cycles","text":""},{"location":"planets_cycles/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":"<p>Time limit: 1.00 s \u00a0|\u00a0 Memory limit: 512 MB</p> <p>You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).</p> <p>You start on a planet and then travel through teleporters until you reach a planet that you have already visited before.</p> <p>Your task is to calculate for each planet the number of teleportations there would be if you started on that planet.</p>"},{"location":"planets_cycles/#input","title":"Input","text":"<p>The first input line has an integer n: the number of planets. The planets are numbered 1, 2, ..., n.</p> <p>The second line has n integers t_1, t_2, ..., t_n: for each planet, the destination of the teleporter. It is possible that t_i = i.</p>"},{"location":"planets_cycles/#output","title":"Output","text":"<p>Print n integers according to the problem statement.</p>"},{"location":"planets_cycles/#constraints","title":"Constraints","text":"<ul> <li>1 &lt;= n &lt;= 2 * 10^5</li> <li>1 &lt;= t_i &lt;= n</li> </ul>"},{"location":"planets_cycles/#example","title":"Example","text":"<p>Input: 5  2 4 3 1 4</p>"},{"location":"planets_cycles/#implentacio","title":"Implent\u00e1ci\u00f3","text":"<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int planetCount = Integer.parseInt(reader.readLine());\n\n        int[] teleporterDestinations = new int[planetCount];\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i &lt; planetCount; i++) {\n            teleporterDestinations[i] = Integer.parseInt(tokenizer.nextToken()) - 1;\n        }\n\n        int[] totalTeleportations = new int[planetCount];\n        boolean[] visitedPlanets = new boolean[planetCount];\n        int[] pathPositionMap = new int[planetCount];\n\n        for (int i = 0; i &lt; planetCount; i++) {\n            if (!visitedPlanets[i]) {\n                ArrayList&lt;Integer&gt; currentTraversalPath = new ArrayList&lt;&gt;();\n                int currentPlanet = i;\n\n                // build current path\n                while (!visitedPlanets[currentPlanet]) {\n                    visitedPlanets[currentPlanet] = true;\n                    pathPositionMap[currentPlanet] = currentTraversalPath.size();\n                    currentTraversalPath.add(currentPlanet);\n                    currentPlanet = teleporterDestinations[currentPlanet];\n                }\n\n                long lengthFromCollisionNode = 0;\n                int cycleLength = 0;\n\n                if (totalTeleportations[currentPlanet] != 0) {\n                    lengthFromCollisionNode = totalTeleportations[currentPlanet];\n                    for (int j = 0; j &lt; currentTraversalPath.size(); j++) {\n                        int planetInPath = currentTraversalPath.get(j);\n                        totalTeleportations[planetInPath] = (int)(lengthFromCollisionNode + (currentTraversalPath.size() - j));\n                    }\n                } else {\n                    int cycleStartIndex = pathPositionMap[currentPlanet];\n                    cycleLength = currentTraversalPath.size() - cycleStartIndex;\n\n                    for (int j = cycleStartIndex; j &lt; currentTraversalPath.size(); j++) {\n                        int planetInCycle = currentTraversalPath.get(j);\n                        totalTeleportations[planetInCycle] = cycleLength;\n                    }\n\n                    for (int j = 0; j &lt; cycleStartIndex; j++) {\n                        int planetLeadingToCycle = currentTraversalPath.get(j);\n                        totalTeleportations[planetLeadingToCycle] = cycleLength + (cycleStartIndex - j);\n                    }\n                }\n            }\n        }\n\n        StringBuilder outputBuilder = new StringBuilder();\n        for (int i = 0; i &lt; planetCount; i++) {\n            outputBuilder.append(totalTeleportations[i]).append(\" \");\n        }\n        System.out.println(outputBuilder);\n    }\n}\n</code></pre>"},{"location":"planets_cycles/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""},{"location":"shortest_path/","title":"Shortest Path","text":""},{"location":"shortest_path/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":""},{"location":"shortest_path/#implementacio","title":"Implement\u00e1ci\u00f3","text":"<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n\n    public static void main(String[] args) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String testsStr = next();\n        if (testsStr == null) return;\n        int tests = Integer.parseInt(testsStr);\n\n        while (tests-- &gt; 0) {\n            String citiesStr = next();\n            if (citiesStr == null) break;\n            int numberOfCities = Integer.parseInt(citiesStr);\n\n            Map&lt;String, Integer&gt; cityNumber = new HashMap&lt;&gt;();\n            Map&lt;Integer, List&lt;Accessible&gt;&gt; cityAccess = new HashMap&lt;&gt;();\n\n            for (int i = 0; i &lt; numberOfCities; i++) {\n                String cityName = next();\n                cityNumber.put(cityName, i + 1);\n\n                int neighborCount = nextInt();\n                List&lt;Accessible&gt; neighbors = new ArrayList&lt;&gt;();\n\n                for (int j = 0; j &lt; neighborCount; j++) {\n                    int dest = nextInt();\n                    int dist = nextInt();\n                    neighbors.add(new Accessible(dest, dist));\n                }\n                cityAccess.put(i + 1, neighbors);\n            }\n\n            int pathsToFound = nextInt();\n\n            for (int i = 0; i &lt; pathsToFound; i++) {\n                String startName = next();\n                String endName = next();\n\n                int start = cityNumber.get(startName);\n                int end = cityNumber.get(endName);\n\n                System.out.println(dijkstra(start, end, numberOfCities, cityAccess));\n            }\n        }\n    }\n\n    public static int dijkstra(int start, int end, int numberOfCities, Map&lt;Integer, List&lt;Accessible&gt;&gt; cityAccess) {\n        int[] distances = new int[numberOfCities + 1];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n\n        distances[start] = 0;\n\n        PriorityQueue&lt;Node&gt; priorityQueue = new PriorityQueue&lt;&gt;();\n        priorityQueue.add(new Node(start, 0));\n\n        while (!priorityQueue.isEmpty()) {\n            Node current = priorityQueue.poll();\n            int currentCity = current.currentCity;\n            int distanceSum = current.distanceSum;\n\n            if (distanceSum &gt; distances[currentCity]) {\n                continue;\n            }\n\n            if (currentCity == end) {\n                return distanceSum;\n            }\n\n            List&lt;Accessible&gt; neighbours = cityAccess.get(currentCity);\n\n            if (neighbours != null) {\n                for (Accessible neighbor : neighbours) {\n                    int newDistance = distanceSum + neighbor.distance;\n\n                    if (newDistance &lt; distances[neighbor.destination]) {\n                        distances[neighbor.destination] = newDistance;\n                        priorityQueue.add(new Node(neighbor.destination, newDistance));\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    static String next() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = reader.readLine();\n            if (line == null) return null;\n            tokenizer = new StringTokenizer(line);\n        }\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        String s = next();\n        if (s == null) return 0;\n        return Integer.parseInt(s);\n    }\n\n    static class Accessible {\n        int destination;\n        int distance;\n\n        public Accessible(int destination, int distance) {\n            this.destination = destination;\n            this.distance = distance;\n        }\n    }\n\n    static class Node implements Comparable&lt;Node&gt; {\n        int currentCity;\n        int distanceSum;\n\n        public Node(int currentCity, int distanceSum) {\n            this.currentCity = currentCity;\n            this.distanceSum = distanceSum;\n        }\n\n        @Override\n        public int compareTo(Node other) {\n            return Integer.compare(this.distanceSum, other.distanceSum);\n        }\n    }\n}\n</code></pre>"},{"location":"shortest_path/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""},{"location":"staircase/","title":"Shortest Path","text":""},{"location":"staircase/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":""},{"location":"staircase/#implementacio","title":"Implement\u00e1ci\u00f3","text":"<pre><code>import java.io.*;\nimport java.math.*;\nimport java.security.*;\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\nimport java.util.regex.*;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\nclass Result {\n\n    /*\n     * Complete the 'staircase' function below.\n     *\n     * The function accepts INTEGER n as parameter.\n     */\n\n    public static void staircase(int n) {\n    // Write your code here\n        for (int i = n; i &gt; 0; i--) {\n            for(int j = i-1; j &gt; 0; j--) {\n                System.out.print(\" \");\n            } \n            int k = i;\n            while (k++ &lt;= n) {\n                System.out.print(\"#\");\n            }\n            System.out.println();\n        }\n    }\n\n}\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(bufferedReader.readLine().trim());\n\n        Result.staircase(n);\n\n        bufferedReader.close();\n    }\n}\n</code></pre>"},{"location":"staircase/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""}]}