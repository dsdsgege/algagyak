{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Algoritmus \u00e9s adatszerkezetek a gyakorlatban","text":""},{"location":"#bevezetes","title":"Bevezet\u00e9s","text":"<p>Ez az oldal az algoritmusok \u00e9s adatszerkezetek a gyakorlatban c\u00edm\u0171 t\u00e1rgyhoz tartoz\u00f3 statikus dokument\u00e1ci\u00f3. Itt ker\u00fclnek list\u00e1z\u00e1sra az \u00e9vk\u00f6rben elv\u00e9gzett feladatok. </p> <p>A navig\u00e1ci\u00f3 egyes elemei megfelelteth\u0151ek egy elv\u00e9gzett feladatnak.</p>"},{"location":"grid_paths/","title":"Grid Paths I.","text":""},{"location":"grid_paths/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":"<p>Time limit: 1.00 s \u00a0|\u00a0 Memory limit: 512 MB</p> <p>Consider an n x n grid whose squares may have traps. It is not allowed to move to a square with a trap.</p> <p>Your task is to calculate the number of paths from the upper-left square to the lower-right square. You can only move right or down.</p>"},{"location":"grid_paths/#input","title":"Input","text":"<p>The first input line has an integer n: the size of the grid.</p> <p>After this, there are n lines that describe the grid. Each line has n characters: <code>.</code> denotes an empty cell, and <code>*</code> denotes a trap.</p>"},{"location":"grid_paths/#output","title":"Output","text":"<p>Print the number of paths modulo 10^9 + 7.</p>"},{"location":"grid_paths/#constraints","title":"Constraints","text":"<ul> <li>1 &lt;= n &lt;= 1000</li> </ul>"},{"location":"grid_paths/#example","title":"Example","text":"<p>Input: 4  ....  ...  ...  *... </p>"},{"location":"grid_paths/#implementacio","title":"Implement\u00e1ci\u00f3","text":"<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n    private static final int MOD = 1_000_000_000 + 7;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String firstLine = reader.readLine();\n        int size = Integer.parseInt(firstLine);\n\n        String[][] grid = new String[size][size];\n        int[][] dp = new int[size][size];\n\n        for (int i = 0; i &lt; size; i++) {\n            grid[i] = reader.readLine().split(\"\");\n        }\n\n        if (\"*\".equals(grid[0][0])) {\n            System.out.println(0);\n            return;\n        }\n        dp[0][0] = 1;\n\n        for (int i = 0; i &lt; size; i++) {\n            for (int j = 0; j &lt; size; j++) {\n                if (i == 0 &amp;&amp; j == 0) {\n                    continue;\n                }\n\n                if (\"*\".equals(grid[i][j])) {\n                    dp[i][j] = 0;\n                    continue;\n                }\n\n                if (i &gt; 0) {\n                    dp[i][j] += dp[i-1][j];\n                }\n\n                if (j &gt; 0) {\n                    dp[i][j] += dp[i][j-1];\n                }\n                dp[i][j] = dp[i][j] % MOD;\n            }\n        }\n\n        System.out.println(dp[size-1][size-1]);\n    }\n}\n</code></pre>"},{"location":"grid_paths/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""},{"location":"planets_cycles/","title":"Planets Cycles","text":""},{"location":"planets_cycles/#feladat-specifikacio","title":"Feladat specifik\u00e1ci\u00f3","text":"<p>Time limit: 1.00 s \u00a0|\u00a0 Memory limit: 512 MB</p> <p>You are playing a game consisting of n planets. Each planet has a teleporter to another planet (or the planet itself).</p> <p>You start on a planet and then travel through teleporters until you reach a planet that you have already visited before.</p> <p>Your task is to calculate for each planet the number of teleportations there would be if you started on that planet.</p>"},{"location":"planets_cycles/#input","title":"Input","text":"<p>The first input line has an integer n: the number of planets. The planets are numbered 1, 2, ..., n.</p> <p>The second line has n integers t_1, t_2, ..., t_n: for each planet, the destination of the teleporter. It is possible that t_i = i.</p>"},{"location":"planets_cycles/#output","title":"Output","text":"<p>Print n integers according to the problem statement.</p>"},{"location":"planets_cycles/#constraints","title":"Constraints","text":"<ul> <li>1 &lt;= n &lt;= 2 * 10^5</li> <li>1 &lt;= t_i &lt;= n</li> </ul>"},{"location":"planets_cycles/#example","title":"Example","text":"<p>Input: 5  2 4 3 1 4</p>"},{"location":"planets_cycles/#implentacio","title":"Implent\u00e1ci\u00f3","text":"<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int planetCount = Integer.parseInt(reader.readLine());\n\n        int[] teleporterDestinations = new int[planetCount];\n        StringTokenizer tokenizer = new StringTokenizer(reader.readLine());\n        for (int i = 0; i &lt; planetCount; i++) {\n            teleporterDestinations[i] = Integer.parseInt(tokenizer.nextToken()) - 1;\n        }\n\n        int[] totalTeleportations = new int[planetCount];\n        boolean[] visitedPlanets = new boolean[planetCount];\n        int[] pathPositionMap = new int[planetCount];\n\n        for (int i = 0; i &lt; planetCount; i++) {\n            if (!visitedPlanets[i]) {\n                ArrayList&lt;Integer&gt; currentTraversalPath = new ArrayList&lt;&gt;();\n                int currentPlanet = i;\n\n                while (!visitedPlanets[currentPlanet]) {\n                    visitedPlanets[currentPlanet] = true;\n                    pathPositionMap[currentPlanet] = currentTraversalPath.size();\n                    currentTraversalPath.add(currentPlanet);\n                    currentPlanet = teleporterDestinations[currentPlanet];\n                }\n\n                long lengthFromCollisionNode = 0;\n                int cycleLength = 0;\n\n                if (totalTeleportations[currentPlanet] != 0) {\n                    lengthFromCollisionNode = totalTeleportations[currentPlanet];\n                    for (int j = 0; j &lt; currentTraversalPath.size(); j++) {\n                        int planetInPath = currentTraversalPath.get(j);\n                        totalTeleportations[planetInPath] = (int)(lengthFromCollisionNode + (currentTraversalPath.size() - j));\n                    }\n                } else {\n                    int cycleStartIndex = pathPositionMap[currentPlanet];\n                    cycleLength = currentTraversalPath.size() - cycleStartIndex;\n\n                    for (int j = cycleStartIndex; j &lt; currentTraversalPath.size(); j++) {\n                        int planetInCycle = currentTraversalPath.get(j);\n                        totalTeleportations[planetInCycle] = cycleLength;\n                    }\n\n                    for (int j = 0; j &lt; cycleStartIndex; j++) {\n                        int planetLeadingToCycle = currentTraversalPath.get(j);\n                        totalTeleportations[planetLeadingToCycle] = cycleLength + (cycleStartIndex - j);\n                    }\n                }\n            }\n        }\n\n        StringBuilder outputBuilder = new StringBuilder();\n        for (int i = 0; i &lt; planetCount; i++) {\n            outputBuilder.append(totalTeleportations[i]).append(\" \");\n        }\n        System.out.println(outputBuilder);\n    }\n}\n</code></pre>"},{"location":"planets_cycles/#feltoltes","title":"Felt\u00f6lt\u00e9s","text":""}]}